/**
 * Service for generating predictions using reality exploitation techniques.
 */

import { RealityExploitationEngine } from "../ml/models/RealityExploitationEngine";
import type { PredictionRequest } from "./types";
import type { ModelPrediction } from "../ml/models/BaseModel";
import { DataService } from "../data/DataService";
import { MarketIntelligenceService } from "./MarketIntelligenceService";
import { PerformanceAnalyticsService } from "./PerformanceAnalyticsService";
import { EnvironmentalService } from "./EnvironmentalService";
import { SocialDynamicsService } from "./SocialDynamicsService";
import { TechnologicalAnalyticsService } from "./TechnologicalAnalyticsService";
import { PsychologicalAnalyticsService } from "./PsychologicalAnalyticsService";

interface PredictionResponse {
  prediction: ModelPrediction;
  confidence: number;
  metadata: {
    physicalMetrics: any;
    performanceMetrics: any;
    psychologicalMetrics: any;
    socialMetrics: any;
    economicMetrics: any;
    technologicalMetrics: any;
    environmentalMetrics: any;
  };
  timestamp: string;
}

export class RealityExploitationService {
  private engine: RealityExploitationEngine;
  private dataService!: DataService;
  private marketIntelligence!: MarketIntelligenceService;
  private performanceAnalytics!: PerformanceAnalyticsService;
  private environmentalService!: EnvironmentalService;
  private socialDynamics!: SocialDynamicsService;
  private technologicalAnalytics!: TechnologicalAnalyticsService;
  private psychologicalAnalytics!: PsychologicalAnalyticsService;

  constructor() {
    this.initializeServices();
    this.engine = new RealityExploitationEngine({
      name: "reality_exploitation",
      type: "ensemble" as any,
      features: this.getFeatureList(),
      target: "probability",
      physicalEnabled: true,
      performanceEnabled: true,
      psychologicalEnabled: true,
      socialEnabled: true,
      economicEnabled: true,
      technologicalEnabled: true,
      environmentalEnabled: true,
    });
  }

  private initializeServices() {
    this.dataService = new DataService();
    this.marketIntelligence = new MarketIntelligenceService();
    this.performanceAnalytics = new PerformanceAnalyticsService();
    this.environmentalService = new EnvironmentalService();
    this.socialDynamics = new SocialDynamicsService();
    this.technologicalAnalytics = new TechnologicalAnalyticsService();
    this.psychologicalAnalytics = new PsychologicalAnalyticsService();
  }

  private getFeatureList(): string[] {
    return [
      // Physical metrics
      "velocity",
      "acceleration",
      "force",
      "energy",
      "efficiency",
      // Performance metrics
      "recentForm",
      "historicalPerformance",
      "matchupAdvantage",
      "restDays",
      "travelDistance",
      // Psychological metrics
      "pressureHandling",
      "clutchPerformance",
      "consistency",
      "focus",
      "competitiveDrive",
      // Social metrics
      "teamCohesion",
      "homeAdvantage",
      "crowdImpact",
      "rivalryFactor",
      "mediaPressure",
      // Economic metrics
      "lineMovement",
      "marketEfficiency",
      "valueOpportunity",
      "riskExposure",
      "liquidityDepth",
      // Technological metrics
      "dataQuality",
      "modelAccuracy",
      "featureImportance",
      "predictionConfidence",
      "systemReliability",
      // Environmental metrics
      "weatherImpact",
      "venueAdvantage",
      "surfaceCondition",
      "timeOfDay",
      "seasonality",
    ];
  }

  async generatePrediction(
    request: PredictionRequest,
  ): Promise<PredictionResponse> {
    // Gather all relevant data
    const features = await this.gatherFeatures(request);

    // Generate prediction using the engine
    const prediction = await this.engine.predict(features);

    // Calculate confidence based on data quality and model agreement
    const confidence = this.calculateConfidence(prediction, features);

    return {
      prediction,
      confidence,
      metadata: {
        physicalMetrics: features.physicalMetrics,
        performanceMetrics: features.performanceMetrics,
        psychologicalMetrics: features.psychologicalMetrics,
        socialMetrics: features.socialMetrics,
        economicMetrics: features.economicMetrics,
        technologicalMetrics: features.technologicalMetrics,
        environmentalMetrics: features.environmentalMetrics,
      },
      timestamp: new Date().toISOString(),
    };
  }

  private async gatherFeatures(
    request: PredictionRequest,
  ): Promise<Record<string, any>> {
    const [
      physicalData,
      performanceData,
      psychologicalData,
      socialData,
      economicData,
      technologicalData,
      environmentalData,
    ] = await Promise.all([
      this.gatherPhysicalData(request),
      this.gatherPerformanceData(request),
      this.gatherPsychologicalData(request),
      this.gatherSocialData(request),
      this.gatherEconomicData(request),
      this.gatherTechnologicalData(request),
      this.gatherEnvironmentalData(request),
    ]);

    return {
      ...physicalData,
      ...performanceData,
      ...psychologicalData,
      ...socialData,
      ...economicData,
      ...technologicalData,
      ...environmentalData,
    };
  }

  private async gatherPhysicalData(
    request: PredictionRequest,
  ): Promise<Record<string, any>> {
    const playerData = await this.dataService.getPlayerPhysicalMetrics(
      request.eventId,
    );
    return {
      velocity: playerData.averageVelocity,
      acceleration: playerData.averageAcceleration,
      force: playerData.averageForce,
      energy: playerData.energyExpenditure,
      efficiency: playerData.biomechanicalEfficiency,
      physicalMetrics: playerData,
    };
  }

  private async gatherPerformanceData(
    request: PredictionRequest,
  ): Promise<Record<string, any>> {
    const performanceData =
      await this.performanceAnalytics.analyzePerformance(request);
    return {
      recentForm: performanceData.recentForm,
      historicalPerformance: performanceData.historicalPerformance,
      matchupAdvantage: performanceData.matchupAdvantage,
      restDays: performanceData.restDays,
      travelDistance: performanceData.travelDistance,
      performanceMetrics: performanceData,
    };
  }

  private async gatherPsychologicalData(
    request: PredictionRequest,
  ): Promise<Record<string, any>> {
    const psychologicalData =
      await this.psychologicalAnalytics.analyzePsychologicalFactors(request);
    return {
      pressureHandling: psychologicalData.pressureHandling,
      clutchPerformance: psychologicalData.clutchPerformance,
      consistency: psychologicalData.consistency,
      focus: psychologicalData.focus,
      competitiveDrive: psychologicalData.competitiveDrive,
      psychologicalMetrics: psychologicalData,
    };
  }

  private async gatherSocialData(
    request: PredictionRequest,
  ): Promise<Record<string, any>> {
    const socialData = await this.socialDynamics.analyzeSocialFactors(request);
    return {
      teamCohesion: socialData.teamCohesion,
      homeAdvantage: socialData.homeAdvantage,
      crowdImpact: socialData.crowdImpact,
      rivalryFactor: socialData.rivalryFactor,
      mediaPressure: socialData.mediaPressure,
      socialMetrics: socialData,
    };
  }

  private async gatherEconomicData(
    request: PredictionRequest,
  ): Promise<Record<string, any>> {
    const marketData = await this.marketIntelligence.analyzeMarketData(request);
    return {
      lineMovement: marketData.lineMovement,
      marketEfficiency: marketData.marketEfficiency,
      valueOpportunity: marketData.valueOpportunity,
      riskExposure: marketData.riskExposure,
      liquidityDepth: marketData.liquidityDepth,
      economicMetrics: marketData,
    };
  }

  private async gatherTechnologicalData(
    request: PredictionRequest,
  ): Promise<Record<string, any>> {
    const techData =
      await this.technologicalAnalytics.analyzeTechnologicalFactors(request);
    return {
      dataQuality: techData.dataQuality,
      modelAccuracy: techData.modelAccuracy,
      featureImportance: techData.featureImportance,
      predictionConfidence: techData.predictionConfidence,
      systemReliability: techData.systemReliability,
      technologicalMetrics: techData,
    };
  }

  private async gatherEnvironmentalData(
    request: PredictionRequest,
  ): Promise<Record<string, any>> {
    const envData =
      await this.environmentalService.analyzeEnvironmentalFactors(request);
    return {
      weatherImpact: envData.weatherImpact,
      venueAdvantage: envData.venueAdvantage,
      surfaceCondition: envData.surfaceCondition,
      timeOfDay: envData.timeOfDay,
      seasonality: envData.seasonality,
      environmentalMetrics: envData,
    };
  }

  private calculateConfidence(
    prediction: ModelPrediction,
    features: Record<string, any>,
  ): number {
    // Calculate confidence based on data quality and model agreement
    const dataQualityScore = this.calculateDataQualityScore(features);
    const modelAgreementScore = prediction.confidence;

    // Weight the scores (adjust weights based on importance)
    const dataQualityWeight = 0.4;
    const modelAgreementWeight = 0.6;

    return (
      dataQualityScore * dataQualityWeight +
      modelAgreementScore * modelAgreementWeight
    );
  }

  private calculateDataQualityScore(features: Record<string, any>): number {
    // Calculate data quality score based on completeness and reliability of features
    const metrics = [
      features.physicalMetrics,
      features.performanceMetrics,
      features.psychologicalMetrics,
      features.socialMetrics,
      features.economicMetrics,
      features.technologicalMetrics,
      features.environmentalMetrics,
    ];

    const scores = metrics.map((metric) => {
      if (!metric) return 0;
      const values = Object.values(metric);
      return (
        values.reduce(
          (sum: number, value: unknown) =>
            sum +
            (typeof value === "number" && value !== null && value !== undefined
              ? 1
              : 0),
          0,
        ) / values.length
      );
    });

    return (
      scores.reduce((sum: number, score: number) => sum + score, 0) /
      scores.length
    );
  }

  async train(data: any[]): Promise<void> {
    await this.engine.train(data);
  }

  async evaluate(
    data: any[],
  ): Promise<{
    accuracy: number;
    precision: number;
    recall: number;
    f1Score: number;
  }> {
    const metrics = await this.engine.evaluate(data);
    return {
      accuracy: (metrics as any).accuracy || 0,
      precision: (metrics as any).precision || 0,
      recall: (metrics as any).recall || 0,
      f1Score: (metrics as any).f1Score || 0,
    };
  }

  async update(data: any[]): Promise<void> {
    await this.engine.update(data);
  }
}
